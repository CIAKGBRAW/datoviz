import itertools
from pathlib import Path
import re
import sys
from textwrap import dedent

from matplotlib import cm, image
import numpy as np
import bokeh.palettes
import colorcet
import webcolors
from PIL import Image

"""
References:

https://www.kennethmoreland.com/color-advice/

The CSV files come from https://www.kennethmoreland.com/color-advice/

"""


COLORCET_NAMES = set(colorcet.palette.keys())
COLORCET_NAMES = {n.lower(): n for n in COLORCET_NAMES}

MATPLOTLIB_NAMES = set(_ for _ in dir(cm) if not _.startswith('_'))
MATPLOTLIB_NAMES = {n.lower(): n for n in MATPLOTLIB_NAMES}

BOKEH_NAMES = bokeh.palettes.__palettes__
BOKEH_NAMES = {n.lower(): n for n in BOKEH_NAMES}
# HACK: fix bug in bokeh name
BOKEH_NAMES["category20b_20"] = "Category20b_20"
BOKEH_NAMES["category20c_20"] = "Category20c_20"

MAX_PALETTE_SIZE = 32

path = Path(__file__).parent.parent / "include/visky/colormaps.h"
texture_path = Path(__file__).parent.parent / "data/textures/color_texture.img"

# Ensure the subdirectorys exist.
texture_path.parent.mkdir(exist_ok=True, parents=True)


def group(n, iterable):
    it = iter(iterable)
    while True:
        chunk_it = itertools.islice(it, n)
        try:
            first_el = next(chunk_it)
        except StopIteration:
            return
        yield itertools.chain((first_el,), chunk_it)


def cmap_lines(l):
    cmap = ['{:3d}, {:3d}, {:3d},   0,'.format(*tuple(_)[:3]) for _ in l]
    if len(cmap) != 256:
        assert len(cmap) < MAX_PALETTE_SIZE
        cmap += ['  0,   0,   0,   0,'] * (MAX_PALETTE_SIZE - len(cmap))
    return ["    ".join(grp) for grp in group(8, cmap)]


def get_colorcet_palette(name):
    colors = colorcet.palette.get(name, None)
    return [webcolors.hex_to_rgb(h) for h in colors]


def get_matplotlib_palette(name):
    arr = (getattr(cm, name)(np.arange(256)))[:, :3]
    arr = (arr * 255).astype(np.uint8)
    # HACK: detect palette
    if np.all(arr[-100:-50, :] == arr[-50:, :]):
        i = 0
        while not np.all(arr[i] == arr[-1]):
            i += 1
        arr = arr[:i + 1, :]
    return arr.tolist()


def get_bokeh_palette(name):
    d = getattr(bokeh.palettes, name, None)
    if isinstance(d, tuple):
        colors = d
    elif isinstance(d, dict):
        k = max(d.keys())
        colors = d[k]
    else:
        print("error with bokeh palette %s" % name)
        return None
    return [webcolors.hex_to_rgb(h) for h in colors]


def get_cmap(n):
    name = MATPLOTLIB_NAMES.get(n.lower(), None)
    if name:
        return get_matplotlib_palette(name)
    name = COLORCET_NAMES.get(n.lower(), None)
    if name:
        return get_colorcet_palette(name)
    name = BOKEH_NAMES.get(n.lower(), None)
    if name:
        return get_bokeh_palette(name)
    # special colormaps in CSV files
    path = Path(__file__).parent / ("%s-table-byte-0256.csv" % n.lower())
    if path.exists():
        return [list(map(int, l.split(','))) for l in path.read_text().strip().splitlines()]
    print("name %s not found!" % n)


# def generate_c_header():
#     colormaps = path.read_text()
#     groups = re.findall(r"^\s+(VKY\_C[A-Z0-9]+\_)([^\,]+)", colormaps, re.MULTILINE)

#     print("#ifndef VKY_COLORMAP_TEXTURE_HEADER\n#define VKY_COLORMAP_TEXTURE_HEADER\n")
#     print("// DO NOT EDIT -- autogenerated by python utils/export_colormap.py")
#     print("// -- %d names found in colormaps.h" % len(groups))
#     print("#include <stdint.h>")
#     print()
#     print("#define DEPTH 4")
#     print()
#     print("uint8_t VKY_COLOR_TEXTURE[256 * 256 * DEPTH];")
#     print()
#     print("const uint8_t VKY_COLOR_TEXTURE_CMAP[VKY_CMAP_COUNT * 256 * DEPTH] = {")

#     cpal_idx = 0
#     last_prefix = None
#     for prefix, name in groups:
#         if prefix == "VKY_CPAL_":
#             if cpal_idx > 0 and cpal_idx % 8 == 0:
#                 print("// end of texture row / group of 8x 32-palettes")
#                 print()
#                 print()
#             cpal_idx += 1
#         if last_prefix != "VKY_CPAL256_" and prefix == "VKY_CPAL256_":
#             print("};\n\nuint8_t VKY_COLOR_TEXTURE_CPAL256[VKY_CPAL256_COUNT * 256 * DEPTH] = {")
#         if last_prefix != "VKY_CPAL_" and prefix == "VKY_CPAL_":
#             print("};\n\nuint8_t VKY_COLOR_TEXTURE_CPAL[VKY_CPAL_ROWS * 256 * DEPTH] = {")
#         l = get_cmap(name)
#         print("// %s%s" % (prefix, name))
#         lines = cmap_lines(l)
#         if prefix != "VKY_CPAL_":
#             assert len(lines) == 32
#         else:
#             assert len(lines) == 4
#         print("\n".join(lines))
#         print()
#         last_prefix = prefix

#     print("};")
#     print()
#     print("#endif")


def parse_defines(text):
    defines = re.findall(r"#define (C[A-Z\_0-9]+)\s+([^\n]+)", text, re.MULTILINE)
    defines = dict(defines)
    defines = {k: v.replace('(', '').replace(')', '') for k, v in defines.items()}
    for k, v in defines.items():
        if v.isdigit():
            defines[k] = int(v)
    for k, v in defines.items():
        if isinstance(v, str) and'+' not in v:
            defines[k] = defines[v]
    for k, v in defines.items():
        if isinstance(v, str) and '+' in v:
            defines[k] = defines[v.split(' + ')[0]] + defines[v.split(' + ')[1]]
    return defines


def generate_binary():
    colormaps = path.read_text()
    defines = parse_defines(colormaps)
    groups = re.findall(r"^\s+(VKY\_C[PM][A-Z0-9]+\_)([^\,\=\s]+)", colormaps, re.MULTILINE)
    texture = np.zeros((256, 256, 4), dtype=np.uint8)
    texture[..., -1] = 255

    last_prefix = None
    row = 0
    col = 0
    for prefix, name in groups:
        l = get_cmap(name)
        assert l is not None
        lines = np.array(l, dtype=np.uint8)
        # lines = np.hstack((l, np.ones((lines.shape[0], 1), dtype=np.uint8)))
        if prefix != "VKY_CPAL032_":
            assert lines.shape == (256, 3)

        if prefix == "VKY_CPAL256_" and last_prefix != prefix:
            row = defines["CPAL256_OFS"]
        elif prefix == "VKY_CPAL032_" and last_prefix != prefix:
            row = defines["CPAL032_OFS"]

        texture[row, col:col + lines.shape[0], :3] = lines

        if prefix in ("VKY_CMAP_", "VKY_CPAL256_"):
            row += 1
        elif prefix == "VKY_CPAL032_":
            col += 32
            col = col % 256
            if col == 0:
                row += 1
        last_prefix = prefix

    # Save the binary file and also PNG for debugging purposes.
    texture.tofile(texture_path)
    print("%s created." % texture_path)

    image.imsave(texture_path.with_suffix(".png"), texture / 255.)
    print("%s created." % texture_path.with_suffix(".png"))



if __name__ == '__main__':
    generate_binary()
